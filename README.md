# Clean Code 

T.박성백 sungback@naver.com  
https://github.com/sungback/Clean-Code

### List
- [Chapter 01. 깨끗한 코드](#1)
- [Chapter 02. 의미있는 이름](#2)
- [Chapter 03. 함수](#3)
- [Chapter 04. 주석](#4)
- [Chapter 05. 형식 맞추기](#5)
- [Chapter 06. 객체와 자료구조](#6)
- [Chapter 07. 에러 핸들링](#7)

<a name = "1"></a>
## Chapter 01. 깨끗한 코드
* 주석없이 이해 가능한 코드
* **인력이 추가되더라도 생산성이 더 좋아지지 않는다.** 
* 원인은 나쁜코드
* 깨진 유리창 이론 - 문제가 발생했을 때 바로 고치지 않으면 금새 더 난장판 됨 
* **클린코드는 한가지 일을 잘한다.** 여러가지 일을 하려고 하지 않는다.
* 클린코드는 하나의 잘 쓰여진 산문처럼 읽혀야 한다. 가독성이 좋아야 한다.
* 수정하기 쉬워야 한다.
* TDD. 테스트 기반의 개발.
* **중복을 없애라.** 클래스/메서드는 한가지 일만 하게하라. 
* 메서드 이름으로 코드가 하는 일을 알 수 있게 하라.
* TIOBE 선정 가장 많이 사용하는 언어  
python > C > Java > C++ ...  
* **보이스카우트 규칙** 변수의 명명, 너무 긴 코드의 분할, 중복의 제거

<a name = "2"></a>
## Chapter 02. 의미있는 이름
* 의도를 밝혀라. 변수명을 의미있게 지어라
* https://github.com/naver/d2codingfont
* 헝가리안 표기법 지양
* 인터페이스 클래스와 구현 클래스를 나눠야 한다면 구현 클래스의 이름에 정보를 인코딩하자   
ShapeFactory -> ShapeFactoryImp
* 클래스 이름은 명사/명사구
* 메서드 이름은 동사/동사구
* **생성자 오버로딩의 경우 정적 팩토리 메서드 사용할것. 싱글톤 패턴을 구현한다.** 직접적인 생성자가 아닌 메소드를 통해 객체를 생성. Calander.getInstance()
* OOP = 속성(변수) + 행동(메소드)


<a name = "3"></a>
## Chapter 03. 함수
* 작게 만들어라
* 한가지만 해라. SOLID
* 블록 잡아서 refactoring  
블록 잡기 > 우클릭 > Refactor > Extract Method
* switch문
> 다형성을 이용하여 abstract factory(추상 팩토리)에 숨겨 다형적 객체를 생성하는 코드 안에서만 switch문을 사용하도록 한다.
* 퍼사드 패턴 : 프론트 컨트롤러 ex) Dispatch servlet 
* 프록시 패턴 : 임시로 만들어서 사용하고 사라지는 것. ex) Spring AOP 
* 부수효과를 일으키지 마라. 한 함수에서 딱 한가지만 수행할 것
* 명령과 조회를 분리하라. 객체 상태변경이나 객체 정보를 반환하는 것 둘 중 하나만 할 것.
* 반복하지 마라 
* 구조적 프로그래밍
* 올바른 함수 짜기
> 단위 테스트 케이스, 코드 다듬기, 단일 기능의 함수 만들기, 이름 바꾸기, 중복 제거... 

<a name = "4"></a>
## Chapter 04. 주석
 * 주석은 필요악이다. 주석으로 나쁜 코드를 보완하려 하지 말라.
 * 좋은주석
	 * 법적인 주석
	 * 정보를 제공하는 주석
	 * 의도를 설명하는 주석
	 * 결과를 경고하는 주석
	 * TODO 주석
	 * 중요성을 강조하는 주석 

<a name = "5"></a>
## Chapter 05. 형식 맞추기
* ctrl + shift + F
* 개념은 빈 행으로 분리하라
* 수직거리 
	* 변수는 사용하는 위치에서 최대한 가까이 선언한다. 
	* 인스턴스 변수는 클래스 맨 처음에 선언한다
	* 한 함수가 다른 함수를 호출한다면 가까이 배치할 것. 호출되는 함수는 호출하는 함수보다 뒤에 배치한다.
* 가로형식 맞추기

<a name = "6"></a>
## Chapter 06. 객체와 자료구조

* OOP 
	* 캡슐화
	* 상속
	* 다형성
* 변수를 private로 하는 것. 외부에서 노출되지 않게 함. -> 캡슐화 (DTO)
*  java lombok으로 getter, setter, tostring등의 메서드 작성을 자동으로 해주는 라이브러리.
* 디미터 법칙 :  
	모듈은 자신이 조작하는 객체의 속사정을 몰라야한다.
* 자료 전달 객체
* 자료구조는 별다른 동작 없이 자료를 노출한다. 
	* Map - HashMap
	* List - ArrayList
	* Set - HashSet
* 함수형 언어 
	* Python
	* JavaScript : Class + 함수형 언어
	* Java : Class + 람다식
		> 람다식 (Lambda Expressions) 
		> 함수적 프로그래밍을 위해 자바 8부터 람다식 지원.   
		객체 자체를 생성하지 않음
* 객체는 동작을 공개하고 자료를 숨긴다.  
그래서 새 동작을 추가하기는 쉬우나 기존함수에 새 자료구조를 추가하기는 어렵다.

<a name = "7"></a>
## Chapter 07. 에러 핸들링
* Unchecked Exceptions를 사용하라
* try - catch - finally 
	* finally 에서는 꼭 자원 해제를 할 것
	* try문에서 transction처럼 동작하는 실행코드
	* catch문에서 프로그램을 일관된 상태로 유지하도록 함


<a name = "8"></a>
## Chapter 08. 에러 핸들링


<a name = "9"></a>
## Chapter 09. 단위 테스트
* **TDD 법칙 3가지**
	* **첫째 법칙:**  실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
	* **둘째 법칙:**  컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
	* **셋째 법칙:**  현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

* **F.I.R.S.T**  

Fast, Independent, Repeatabel, Self-Validateing, Timely


<a name = "10"></a>
## Chapter 10. 클래스


<a name = "11"></a>
## Chapter 11. 시스템
* **의존성 주입**
Spring에서는 @controller 처럼 어노테이션 형태로 사용하면, 

<a name = "12"></a>
## Chapter 12. 창발성
* 모든 테스트를 실행하라  
	**인터페이스, 추상화 등과 같은 도구를 사용해 결합도를 낮춘다.**
* 리팩터링을 하라  
	
* 중복을 제거하라  
 

<a name = "13"></a>
## Chapter 13. 동시성
* 멀티 스레드
* 프로그램, 프로세스, 스레드
	* 프로그램 - 실행순서
	* 프로세스 - 프로그램이 메모리에 올라감
	* 스레드 - 작은 작업단위

* 스레드 세이프 : vector 는 멀티스레드 가능, Arraylist는 불가
* **스레드 환경에 안전한 컬렉션**
	* java.util.concurrent 패키지는 멀티 스레드 환경에서 사용할 수 있는 컬랙션들을 제공한다. ConcurrentHashMap의 경우에는 일반 HashMap보다 대부분의 상황에서 더 좋은 퍼포먼스를 제공한다. 만약 배포 환경이 자바 5버전 이상이라면 이 패키지를 활용하자.
	*  RenntrantLock
	* Semaphore
	* CountDownLatch




<a name = "14"></a>
## Chapter 14. 점진적인 개선

* 15장 JUnit코드리뷰
* 16장 
* 17장 냄새와 휴리스틱 
https://velog.io/@jiffydev/Clean-Code-%EB%83%84%EC%83%88%EC%99%80-%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1





# Refactoring 2nd Edition


리팩토링은 수시로 하는 것이다.
TDD와 연결되어 사용한다.

* SOLID
https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)  


# Java Performance
* J2EE 디자인 패턴
	* Front Controller
	* Transfer Obj
	* DAO 패턴 - mybatis 


* MVC 패턴
	- Model : 저장
	- View
	- Controller : 

* 성능상으로 볼 때, getter / setter를 만들지 않는 것이 더 빠르다.

* Story 03
	* 반복문안에서 String 끼리 더하지 말라
		String은 고정값이라 String끼리 더하는 경우 매번 새로운 주소에 새로운 String값을 넣는다. 메모리 및 시간 불리
	* StringBuffer 나 String Builder 사용하기 String Builder는 같은주소를 갖는다.
>   버퍼와 빌더는 무엇이 다를까? StringBuffer는 ThreadSafe 설계되어 있어서, 여러 스레드가 하나의 StringBuffer 객체를 처리해도 전혀 문제가 되지 않으면, StringBuilder는 단일스레드에서의 안전성만을 보장한다.

* Story 04 
	* Vector : 동기화 보장. 여러 스레드 접근 할 수 없음
	* TreeSet : 
	* HashSet : 



# 시험 정리


## Clean Code
* 01. 깨끗한 코드
	* 나쁜코드를 하면 어떻게 되는가   
	* Killer app 하나로 대박난 회사가 머지 않아 망한 일이 있었다. 그 원인은 나쁜 코드였다. 
	* 나쁜 코드가 쌓일 수록 그 팀의 생산성은 떨어지고 이윽고 0에 수렴한다.
	* 새 인력을 투입했으므로 생산성이 늘어날 것 같지만 그렇지 않다.
	*  난장판을 품는 데에 드는 비용
	*  코드는 어떻게 짜야 하는가
		* 코드는 즐겁게 읽혀야 한다.
		* 
* 02. 의미있는 이름
	* 의미있는 이름을 짓는 규칙이 아닌것?
	* 목차에서 보고. 상식선에서 아닌것

* 03. 함수
	* 함수를 만들 때 해야하는 것이 아닌것?	목차에서 보고 상식선에서 아닌 것

* 04. 주석
	*  좋은 주석이 아닌것. 목차 정리하기

* 05. 형식 맞추기
	* 문제 안냄

* 06. 객체와 자료구조
	* 문제 안냄

*  07. 에러 핸들링
	* 목차에서 보기

* 08. 경계
	* 목차에서 보기
	* 아닌것찾기

* 09. 단위 테스트 
	*  TDD 법칙 3가지 아닌것찾기
	* FIRST 아닌 것 맞는것 5개 있는데 아닌것 1개 있음
	
*	10. 클래스
	*	목차 아닌것

* 11. 시스템
	* 목차 와 큰 글씨만 보기

* 12. 창발성
	* **켄트 벡**이 제시한  **단순한 설계**  규칙 네 가지가 소프트웨어 설계 품질을 크게 높여준다고 믿는다. 켄트 벡은 다음 규칙을 따르면 설계는 '단순하다'고 말한다.
	* 모든 테스트를 실행한다.
	* 중복을 없앤다.
	* 프로그래머 의도를 표현한다.
	* 클래스와 메서드 수를 최소로 줄인다.

* 13. 동시성
	* 동시성 방어 원칙
		* 단일 책임 원칙
		* 따름 정리: 자료 범위를 제한하라 
		* ...
		* 
	* 스레드 환경에 안전한 컬렉션
		* 
	* 실행모델을 이해하라

## Refactoring

*	리팩토링을 하는 이유가 아닌것
*	코드에서 나는 악취가 아닌것

## Performance
* 디자인 패턴이 아닌것 
	* front controller
	* Transfer Object 
	* Data Access Object 
* 기본 어플리케이션 코딩중 잘 되어 있지 않은 것? 
* DB 상식선에서..
